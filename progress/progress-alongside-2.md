
# 琢磨钻研：5. 网络 (Network)  -  8. 简化版支付确认 (Simplified Payment Verification)






## 5. 


“每个节点【开始】为自己的区块寻找符合要求的工作量证明。”
> 为什么？额外加一个“开始”？那就更能清晰的表明，这是其中一个步骤，是属于这几步里面的。有那种Progress感觉。


Each node works on finding a difficult proof-of-work for its block.
> 直接翻译成困难的，肯定是很傻。像李笑来的版本，说是有一定难度的，这个也算是为了遵循原文而委屈了表达吧。
> “符合要求的工作量证明”，不知道这个是否更符合意思、符合Context？
>
> ✅ 更贴近机制的本质，因为所谓“困难”，就是指必须满足特定条件的工作量证明（比如哈希前缀有多少个零）。


Nodes express their acceptance of the block by working on creating the next block in the chain, using the hash of the accepted block as the previous hash.
> “众多节点向网络表示自己接受这个区块的方法是，在创建下一个区块的时候，把被接受区块的哈希当作新区块之前的哈希。”
> “节点们通过将已接受区块的哈希作为上一个哈希，来创建下一个区块，以此表示对该区块的认可。”
>
> 你会发现，这第一版翻译很精妙，他居然是完全遵循原文的含义顺序的。第一块说的是接受区块，by之后，就再说创建下一区块。再到了第三块，说的是哈希的相关使用。
> 但我总觉得这样太别扭。而第二版本，其实是把这顺序完全打乱。我希望效果是更好理解，而不是徒增复杂。
>
> 
> 应遵循"核心动作前置"原则：
> 首要信息是"节点如何表达接受" → "通过创建下一个区块"
> 次要信息是"具体如何创建" → "使用前一区块哈希"
> 第一版：按英文语序直译，导致中文出现不自然的因果链条




Nodes always consider the longest chain to be the correct one and will keep working on extending it. 

> 节点始终认为最长链是正确的，且会不断向其添加新数据。
> 节点始终认为最长链是正确的，会继续扩展它。
> 节点总是默认最长的链是正确的那个，并在此基础上继续工作。
> 
> 你难道能说，这几个版本哪个是错的吗？我觉得各有优劣。
> 比如说always，你翻译做始终或者总是，其实都行，只是程度上稍微有些差异。而同时那个one，我觉得你又要把它表现出来。
> 再者就是，他这里的继续工作，工作是什么呢？
> 工作本来就是添加新数据，那所以说到底用哪个更合适呢？你也不知道。而原文说的又是“扩展它”。
> 最后，我觉得那个额外增加的“在此基础上”是OK的。



“有些节点会先接收到其中一个，而另外一些节点会先接收到另外一个”

> 这一句话特别臃肿，有没有更好的翻译方式呢？可不可以直接浓缩成一句话：各节点率先接收到的新区块不同。 而总体上，有没有更加直接、长期有用的翻译呢？
> 
> 它这里还行，省掉了很多原意表达的内容，但其实省掉了本身也没什么。
> 然后同时加上了很多东西，比如说：“统一切换”，一定是统一的吗？
> 但从利益角度出发，大概率会是统一的。因为只有这有好处，在好处这么明确的情况下，应该很少有人转头干无用功吧？


“在此基础上持续延展它”
> 在此基础上，这几个字应该不算画蛇添足。因为，你先得认可，之后才来在这条链上工作。那就表示你接受这条链的原有情况。
> 而之前我写的是，继续延展它，但这里没有continue，是Keep。
> Working的话，其实延展就已经包括那一层意思，所以我觉得没必要再塞进来。


“若有两个新区块同时被广播，”
> 像他这里，就算是把原文中原本包含的主体拿掉了，为了表达的更简洁。而我们之前做的工作，有很多都是：原文中没有主体、客体，我们在翻译时给他塞进来。

“in case it becomes longer”
> 谁都知道，这表达的是变得更长，但你如果直接这样说的话，别人肯定不明所以，为什么要防止它变得更长呢？
> 再进一步来说，就是为了防止它成为其中的最长链。这样，被认为是正确的那一个，就要更替了。


---


New transaction broadcasts do not necessarily need to reach all nodes. As long as they reach many nodes, they will get into a block before long. Block broadcasts are also tolerant of dropped messages. If a node does not receive a block, it will request it when it receives the next block and realizes it missed one.


新的交易不见得一定要广播到达所有的节点。只要到达足够多的节点，那么没多久这些交易就会被打包进一个区块。区块广播也容许一些消息被丢弃。如果一个节点并未接收到某个区块，那么这个节点会在它接收到下一个区块的时候意识到自己错失了之前的区块，因此会发出补充那个遗失区块的请求。

新交易的广播不必抵达所有节点，只要能触达足够多的节点，它们迟早会被打包进区块。区块的广播也同样容忍消息丢失。如果一个节点没收到某个区块，它会在收到下一个区块时发现自己漏掉了一环，并主动请求补上这个缺失的区块。

> 在这一段里，你同样可以看到特别多的差异，但无论差异如何，他们都是为了尽可能好的表达好原意。
> 翻译的哲学并不是,完整的把结构表示出来。我觉得还是:得其意，忘其形。
> 
> 比如说这里，其实第一句的动词是reach，所以，把广播放在主语位置，可能更合适。而其实本就这样的贴近原文，也更好理解。
> 第一版里，动词直接是“广播”，但原文中这是主语位置。
> 然后reach，翻译做触达，也OK。

“dropped messages”
> 那你说翻译，做信息的丢失，会不会有点不妥？因为到这里，主角就变成了丢失。
> 但我觉得也没必要纠结在这些小细节上吧。
> 你无论说是：容许一些信息被丢失，还是容忍信息丢失，又或者是容忍一些信息的丢失，
> 表达的不都一个意思吗？


“漏掉了一环”
> 这个翻译，看似是个大胆的动作，但其实后面跟上的那一句，就恰好补充说明了，这一环是什么，就是那个缺失区块。
> 
> ✅ 你说得对。“漏掉一环”是“意”的处理，而非拘泥“形”，属于恰到好处的语义润色，尤其适合非技术读者。它先用比喻方式引导理解，再落地解释。
> 可以保留，或使用更朴素表达如“发现漏了一个区块”，看受众是否熟悉区块链术语。


“意识到自己漏掉了一环，并主动请求补上这个缺失的区块。 VS  发现自己漏掉了前一区块，并主动请求补全。”
> 肯定是选后一个版本。他字更少，同时，更好理解。对比下来的话，前一个版本，【一环】的表达显得有点冗余，不需要再用这种比喻方式来引导理解。
> 因为直接用本体就可以描述得更清楚。而最开始的那个条件句里也说了，漏掉的就是那个没收到的区块。


“will request it”
> 你看原文这样子，别人本身是个代词放那里，所以具体是什么请求呢？需要翻译者自己开动脑筋，想到最合适的描述。
> 第一个版本，是直接把描述放在了请求前面，做定语。
> 第二个版本，请求和原文是一致的，都当作动词处理。请求后面的内容，宾语部分，那就是我们添额外添加的描述。
> 
> 有没有必要用，主动，这样的词来修饰呢？我觉得是锦上添花。虽然说原文里没有。





## 6. 


By convention, the first transaction in a block is a special transaction that starts a new coin owned by the creator of the block. This adds an incentive for nodes to support the network, and provides a way to initially distribute coins into circulation, since there is no central authority to issue them. The steady addition of a constant of amount of new coins is analogous to gold miners expending resources to add gold to circulation. In our case, it is CPU time and electricity that is expended.

按照约定，每个区块的第一笔交易是一个特殊的交易，它会生成一枚新的硬币，所属权是这个区块的生成者。这么做，使得节点支持网络有所奖励，也提供了一种将硬币发行到流通之中的方式 —— 在这个系统中，反正也没有一个中心化的权威方去发行那些硬币。如此这般稳定地增加一定数量的新硬币进入流通，就好像是黄金开采者不断耗用他们的资源往流通之中增加黄金一样。在我们的系统中，被耗用的资源是 CPU 工作时间和它们所用的电力。

按照规则，每个区块的第一笔交易是笔特殊交易：它会创造一枚新币，奖励给该区块的创建者。这既激励了节点维护网络，也解决了在没有中心机构的情况下如何发行初始货币的问题。新币以稳定的速率进入流通，就像矿工消耗资源挖出黄金一样。在我们的系统里，被消耗的资源是 CPU 时间和电力。

> 第一小句，就让我觉得有点不对劲。肯定是翻译做，约定。一旦你用什么规则、规定，在中文语境内，我总感觉后面这两个词，又会有一种权力集中的感觉。
> 
> 翻译到后面，我更多的感受是什么呢？
> 我觉得很多情况下都仅仅只是表达方式的不同，但所指向的，依然是同一个东西。你比如说在它的版本里，他就很显性的表达出了own这个词。
>
> “所属权是这个区块的生成者”，很忠于原文，但生硬得要命。
> 第二版给出的翻译，那就直接说是，奖励给了。
> 
> 再比如说，发行到流通之中，你说有没有必要刻意的显示出来呢？
> 其实发行这个词本身，就已经暗含了这层概念，因为你发行本身，就是让它进入到流通之中。
> 而同时第二版，后面他已经说了，进入流通。
>
> “反正也没有”，可能确实比较好的复原了“since there is”，但第二个很明显更清爽。
> 
> 后面那一段，很明显过于臃肿，没必要这么说，虽然是为了完整的复现原意。
> 但很明显，我们这个表达式更清爽。稳定增加一定数量的新硬币，不就相当于，新币以稳定速率进入吗？


> Add gold to circulation，“将黄金注入流通”，明显翻译的更好，
> 挖出黄金，很明显不是更好的。而其实发行和注入到流通之中，想表达的是一个概念。
>
> 也有理由，因为挖出这个动作符合矿工这个类比。


> 既激励了节点来维护网络，既为节点维护网络提供了激励，
> 
> 这2句，其实不一样。前者重在“动作”，后者重在“性质”。
> 从“激励”这个词的属性也能看出来。于是遵循原文。


> The steady addition of a constant of amount of new coins
> 如此这般稳定地增加一定数量的新硬币 VS 这种新币的稳定增发
>
> 第二版，不是最好的浓缩吗？
> 而且表达的是相同的含义。


```
1.  **`By convention`**：这个力的方向是“非强制、共识、协议”。所以“约定”远胜于“规则”。你的判断极准。
2.  **`owned by the creator`**：这个力的方向是“归属、激励”。“所属权”只说了归属，是静态的。“奖励给”，一步到位，把归属和激励的目的都说了，是动态的，更有力。
3.  **`distribute coins into circulation`**：这个力的方向是“从无到有，进入公共领域”。“发行”一词，本身就包含了“进入流通”的含义。“发行到流通之中”是同义反复，力被稀释了。“进入流通”则略显平淡。核心是“发行”。
4.  **`analogous to gold miners`**：这个力的方向是“建立一个强类比，让读者秒懂”。“黄金开采者……增加黄金”太啰嗦，力道不足。“矿工……挖出黄金”，瞬间建立图像，力道千钧。在这里，“挖出”比“注入”更好，因为它更质朴，更符合“矿工”这个主体形象。
```

---


The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.

奖励还可以来自交易费用。如果一笔交易的输出值小于它的输入值，那么其中的差额就是交易费；而该交易费就是用来奖励节点把该交易打包进此区块的。一旦既定数量的硬币已经进入流通，那么奖励将全面交由交易手续费来完成，且绝对不会有通货膨胀。

激励也可能来源于交易费。如果一笔交易的输出总额小于输入总额，其差额就是交易费，这笔费用会一并奖励给打包该交易的区块创建者。当货币发行量达到预设上限后，系统的激励将完全来自交易费，从而实现零通货膨zhang。



> 其他的都是些微小差异，后面这一段，值得来说说。
> > “一并”，第二版更好，显性体现出“is added to”。
> 发现了吗？原文中没有主体，“节点”，但2版本都显性点出来了。
> 
> 他这一句关于交易费的说明，他是个主系表结构，用来解释这个交易费的性质，对吧？就说它是用来干嘛的。
> 当然在原句里，也确实就是因为这个从句本身，就是放在这个交易费身上的。而到了我们这句，这里就更顺畅。而节点，本就是那个区块创建者，所以也没什么好搞分歧的。
> 
> 
> 后面一句，很明显你就可以看到，它是很强硬的，把整个结构照搬了过来。
> 但我们这里就是按照更加简洁的原则、得其意忘其形的原则。他那个读起来比较生涩的句子，想表达的意思，跟我们是一样。
> 
> 既定数量的硬币进入流通，那不就相当于是，发行量达到预设的上限吗？
> 奖励将全面由手续费来完成，那不就相当于是，奖励完全来自于手续费吗？
> 就，表达的是一个东西，只不过他那表达方式是为了遵循原文的结构。



> “给打包该交易的区块创建者”
> 这种完全属于画蛇添足，原文说得清清楚楚，这个差值就是笔交易费，会加到包含这个交易的区块的奖励之中。完全没提到这个奖励会给谁，虽说大家都知道。


*   `is added to`：“一并”很好，但还可以更精炼。“计入”一词，在中文语境中兼具“计算并纳入”之意，干净利落。
*   `transition entirely to`：“全面交由……来完成”太啰嗦，“完全来自”是结果，但“过渡”这个动态过程更关键。
*   `predetermined number of coins have entered circulation`：“发行量达到预设上限”，精准。
  
> 其实不够精准，原文中，谓语是“have entered”，但我们翻译的是“达到上限”。
> “待预设的货币总量发行完毕”，优化版救命。
>
> “货币总量”，“发行”，这个事物和那个动作。怎么能连起来呢？一个被规定的数字还能被发行吗？当然是货币被发行。更好的版本应该是：一旦预设总量的货币发行完毕。


“承担”二字，不仅说明了来源，更暗示了其在经济模型中角色的转变和“接力”的责任，比“来自”更有深度。
> 确实，“奖励将全面交由…来完成”，像使用【完成】，就没那么有力。


---


The incentive may help encourage nodes to stay honest. If a greedy attacker is able to assemble more CPU power than all the honest nodes, he would have to choose between using it to defraud people by stealing back his payments, or using it to generate new coins. He ought to find it more profitable to play by the rules, such rules that favour him with more new coins than everyone else combined, than to undermine the system and the validity of his own wealth.

奖励机制也可能会鼓励节点保持诚实。如果一个贪婪的攻击者能够网罗比所有诚实节点都更多的 CPU 算力，他必须做出一个选择：是用这些算力通过把自己花出去的钱偷回来去欺骗别人呢？还是用这些算力去生成新的硬币？他应该能够发现按照规则行事是更划算的，当前规则使得他能够获得比所有其他人加起来都更多的硬币，这显然比暗中摧毁系统并使自己的财富化为虚无更划算。

这种激励机制也能鼓励节点保持诚实。一个掌握了超过半数算力的贪婪攻击者，将面临一个选择：是利用算力偷回自己刚花掉的钱来行骗，还是用它来创造新币？他会发现，遵守规则对他更有利——因为这能让他挖到比所有人加起来都多的新币，这远比破坏系统、让自己财富的根基不保要划算得多。


> 一样的道理，他尽量尊重了原作者的一字一句的原文。
> 但第二版，可能就更强调翻译含义，而不是翻译形态。大致一看，表达的都是一个东西。
> 
> 比如说，比所有诚实节点都更多，那不就是半数以上吗？这是个数学问题。
>
> “如果一个贪婪的攻击者，能够掌握超半数的算力（即，比所有诚实节点的都更多），他将面临一个选择”
> 但我这个综合版，是不是有点多了？
>
> 我知道他那里又有一个by，就是说“通过…来…”，然后第一版，就非常显性的点出了。没必要。
 

> 最后一句，有点误差。
> 
> 比如说，第二版里的“这”，到底指代的是前面的什么呢？是遵守规则这个动作，还是指规则本身呢？别人原文中想说的，就是这些规则对他更利好。而第一版也点出来了。
> 
> 然后李笑来的版本里，他把那个undermine，翻译的比较drama。我们这可能就更朴素。
>
> 
> 这个validity，你说怎么翻译呢？根基不保，勉强还行。
> 如果生硬翻译的话，那可能叫做，有效性，对吧？
> 就是说，你把系统破坏了，那你在这个系统中的财富的有效性没了，但纯直接翻译成有效性，肯定不行。
> ““动摇财富根基”翻出了原文的“validity”这个比较抽象的词，精准且具象。”
> “它把抽象的“有效性”转化为了**具体、有画面感的“根基”**，让读者能瞬间感受到那种“**皮之不存，毛将焉附**”的危机感。这比干巴巴的“有效性”好一万倍。”
> 
>
> “他会发现，按规则行事对他更有利，因为这些规则能让他获得比其他所有人加起来都多的新币 —— 这远比破坏系统、动摇自己财富的根基要划算得多。”
> 第三版，“ought to”，第一版的“应该能够”，很好，但没必要。
> “划算，有利”，都觉得还不够好，不够好的映射出“profitable”，即直接的金钱收益。“有利可图”可能更好。





> “such rules that favour him”
>
> favour，不知道为什么，我总有一种想翻译成，【更利好】的冲动。当然你直接这样说，肯定太抽象，还要跟后面的with搭配起来，所以还是变成具体情景下的动词，那就是：获得……
> “👉 用“让他获得……”是一次**把抽象动词具象化**的优选操作，翻得准又好懂。”
 
> “而破坏系统则会动摇他自身财富的根基。”
>
> 明显这个是更清爽的版本，因为别人原文,本来也就只说了than to.
> 他这个是跟第一段对比起来的。就是说：more profitable的动作是play by rules，而不是undermine……
> 但我还是更喜欢这种解释的更全的。
> 当然，这个句子确实也组的长。两个对比还被第二段隔开。



```
*   `more CPU power than all the honest nodes`：你判断极准，就是“超过半数算力”。无需啰嗦。
*   `profitable`：“划算”、“有利”都偏弱。“有利可图”是你找到的精准之词，直击“利润”核心。
*   `such rules that favour him`：第二版的“这”确实有歧义。必须点明是“规则”本身在使他获利。
*   `validity of his own wealth`：“根基不保”是神来之笔，比“有效性”强一万倍。“有效性”是技术词汇，“根基”是财富的本质。

“终将发现”对应`ought to find`，表达一种基于理性的必然，比“应该能够”更具宿命感和力量感。
“挖到”新币，呼应了前文的“矿工”和“挖矿”的类比，保持了整个白皮书核心意象的一致性。
```

> 终将发现，这个词有点太drama了，没必要搞这种宿命感，所以还是换成了将会发现。
> 同时，别人原句也也没直接点出具体动作，只是favour。
> 因此你这里说挖到，其实是加了额外的context。当然，知道这个币的获取方法就是挖，但【获得】可能是更直给的表达。



---



（1.0修改时）

第一段：关于“约定”和“发行”

-   **`By convention` vs. `规则`**：用“约定”或“惯例”远胜于“规则”。“规则”带有强制性、自上而下的意味，而“约定”则体现了去中心化系统里，由参与者共识形成的最佳实践。这是气质上的差别，至关重要。
-   **`发行到流通之中`**：这是典型的翻译腔，啰嗦。你的版本“发行初始货币”和“新币进入流通”干净利落，抓住了核心。

**优化说明：**
这个版本只在措辞上微调，使其更紧凑。“奖励给”准确传达了 `own` 在此处的真实含义（作为激励的结果）。
“如何首次发行货币”精准地对应了 `initially distribute coins`。

---

第二段：关于“交易费”和“通胀”

-   **`差额就是交易费；而该交易费就是用来...`**：这种解释性从句，直接拆分成两个短句，更符合中文阅读习惯。你的版本“其差额就是交易费，这笔费用会一并奖励给...”已经非常好了。
-   **`既定数量的硬币已经进入流通`**：你的翻译“当货币发行量达到预设上限后”是神来之pe。它没有拘泥于字面，而是直接说出了这句话在比特币世界里的**真实含义**——2100 万枚的总量上限。这正是“得其意，忘其形”的典范。

**优化说明：**
这个版本在你的基础上，把“零通货膨胀”缩为“零通胀”，更具冲击力。“一同奖励给”比“一并”稍微更书面一点。整个逻辑链条“差额 -> 交易费 -> 奖励 -> 最终来源”非常清晰。

---

第三段：关于“诚实”和“贪婪”

这一段的心理博弈和深层逻辑，最考验翻译功力。

-   **`more CPU power than all the honest nodes`**：你翻译成“超过半数算力”是完全正确的。这又是一个超越字面的精准释义。
-   **`rules that favour him`**：你发现了这里的指代关系，非常敏锐。李笑来版本的“当前规则使得他能够获得...”处理得很好，直接把因果点明。你的版本“因为这能让他挖到...”如果把“这”明确为“规则”，就完美了。
-   **`validity of his own wealth`**：这是最难翻的一句。“根基不保”已经是非常精彩的意译了。它把抽象的“有效性”转化为了具体、有画面感的“根基”，让读者能瞬间感受到那种“皮之不存，毛将焉附”的危机感。这比干巴巴的“有效性”好一万倍。

**优化说明：**
微调了你那个绝佳的意译：“**动摇自己财富的根基**”，它比“根基不保”更主动，更能体现`undermine`（从下方破坏）的动作感。




## 7. 


Once the latest transaction in a coin is buried under enough blocks, the spent transactions before it can be discarded to save disk space. To facilitate this without breaking the block's hash, transactions are hashed in a Merkle Tree[^2][^5][^7], with only the root included in the block's hash. Old blocks can then be compacted by stubbing off branches of the tree. The interior hashes do not need to be stored.

如果一枚硬币最近发生的交易发生在足够多的区块之前，那么，这笔交易之前该硬币的花销交易记录可以被丢弃 —— 目的是为了节省磁盘空间。为了在不破坏该区块的哈希的前提下实现此功能，交易记录的哈希将被纳入一个 Merkle 树[^2][^5][^7]之中，而只有树根被纳入该区块的哈希之中。通过砍掉树枝方法，老区块即可被压缩。内部的哈希并不需要被保存。

当一笔交易被足够多的新区块确认后，它之前的旧交易记录就可以被安全地删除，以节省磁盘空间。为实现这一点而不破坏区块的哈希完整性，我们将区块内的所有交易构建成一棵默克尔树（Merkle Tree）[^2][^5][^7]，并只将该树的树根哈希值记录在区块头里。如此，只需剪掉不再需要的树枝，旧区块就能被有效压缩，而无需存储那些中间过程的哈希。

> 这里的第一句，这个先后顺序的说明，当时就难住我了。同时我也觉得非常有意思。看第一版，就直接这么强硬的翻译过来。但实际上起来很拗口，难理解。
> 原文里，确实也没有刻意的强调，是怎样的先后顺序，而且本就是相对，只是表述方式的差异。
> 
> 而其实Discard，对应过来的话，确实就是丢弃。但安全的删除，肯定也没问题。
> “ —— 目的是为了”，这太臃肿了。“以”，直接搞定。
> 
> 另外注意到，without，第一版那边理解成了，前提。第二版，则是用“而”，连接起来。
> 
> 又到了最难的地方，像这种hash，名词作动词，本来就不好翻译。当然，我觉得这里的纳入和构建，都已经算是很好的了，比较优秀的做到复原。但，用主动句式，还是被动呢？
> 原文中是直接说，交易被拿来hash，第二版也比较保守，直接说交易。但第一版更细，说，被hash的对象是交易记录的哈希。能是什么东西被纳入呢？那肯定也是哈希值。
> 
> 后面，这里你无论说不说其实都是一样的，2版本差别好像不大，只是Context差异。
> 比如说，“只有树根被纳入”，是树根的什么被纳入呢？它的哈希值。“被纳入区块头里”，被纳入区块头里的是什么呢？其实也还是哈希。
>
> 
> 最后一句。虽然说，后面的这个版本，里面有很多原文中并没有的修饰，但其实都是可以辅助理解。第二版，也换成了主动句式。
> 比如说，“不再需要的”、“有效”，以及“中间过程的”，都是符合语境的。既然树枝是要砍掉的，那不就说明不再需要了吗？


```
**原文的目的**：描述一个**机制**。这个机制要解决一个**问题**（磁盘空间），同时满足一个**约束**（不破坏哈希）。它描述的是一个客观系统，语气是中立、陈述性的。

**道：抓住机制的“因果”与“目的”链条。**

*   **目的**：节省空间。
*   **动作**：丢弃旧交易。
*   **约束**：不能破坏区块哈希。
*   **方案**：用默克尔树。
*   **原理**：只把树根写入区块，而非全部交易。
*   **结果**：可以剪掉树枝（丢弃交易），内部哈希也无需存储。

一个好的翻译，必须清晰地呈现这个逻辑链。


**术：选择最“锋利”的中文动词，用最凝练的结构。**

*   `buried under enough blocks`: T2的「确认后」抓住了意，但「覆盖」一词更佳，既有“之后”的时间感，又有“堆叠”的空间感，精准、有力。
*   `facilitate this without breaking`: 「为实现此目的，且不破坏...」结构最清晰。T1的「前提」太硬，T2的「而」太弱。
*   `are hashed in`: 「被构建成」或「被组织成」。这里用被动语态更符合原文的客观陈述，避免引入“我们”这个主语。
*   `stubbing off branches`: 「剪除树枝」或「修剪树枝」。「剪除」比「砍掉」更精确，比「剪掉」更书面。
*   `interior hashes`: 「内部哈希」是标准术语，直译即可，比「中间过程的哈希」更简洁。
```




A block header with no transactions would be about 80 bytes. If we suppose blocks are generated every 10 minutes, 80 bytes * 6 * 24 * 365 = 4.2MB per year. With computer systems typically selling with 2GB of RAM as of 2008, and Moore's Law predicting current growth of 1.2GB per year, storage should not be a problem even if the block headers must be kept in memory.

一个没有任何交易记录的区块头大约是 80 个字节。假设每十分钟产生一个区块，80 字节乘以 6 乘以 24 乘以 365，等于每年 4.2M。截止 2008 年，大多数在售的计算机配有 2GB 内存，而按照摩尔定律的预测，每年会增加 1.2 GB，即便是区块头必须存储在内存之中也不会是什么问题。

一个不含交易的区块头大约只有 80 字节。即便按每 10 分钟产生一个区块的速度计算，一年也只会增加 4.2MB 的数据。考虑到 2008 年的计算机普遍配置 2GB 内存，且根据摩尔定律，存储容量仍在快速增长，因此，即便所有区块头都保存在内存里，存储也不是问题。


> “没有任何”，太僵硬。“只有”，“即便…也…”，语气更强，读者会更好理解作者要表达出的量小的意思。这一段，总体上是第二版胜出。
>
> “即便按每十分钟产生一个区块的速度计算，80 字节乘以 6 乘以 24 乘以 365，一年也只会增加 4.2MB 的数据。”
> 第二句，我是各取所长来处理的，我觉得不算画蛇添足，但确实多了很多。
> 因为你如果，是直接强硬的把那个等式后面说出来，那读者可能没有意识到这意味着什么，但有这一句说明的话，他就好理解了，你一年也只会增加这么多数据。他想强调的是，少。
> 
> “截止、在售”，我觉得是第一版的精妙之处，第二版，就没有把selling表现出来。
> 为什么要说截止呢？我觉得，能更显性地强调时间点，表达“现在是这样，以后不一定”，虽然说原文中没有until。
> 
> 最后一句，其也只是翻译上的差异。表达的不是一个意思吗？
> 
> “且按照摩尔定律的预测，存储容量仍在快速增长（每年增加 1.2 GB）。因此，即便区块头都必须存储在内存里，也不是问题。”
> 我各取所长的版本。
> 第一版遵循原文，直接点出增加量，但作者实际上想说的，就是储存流量的快速增加，但第二版又没具体点出数据，所以把两者结合一下。
> 而同时，对于最后一句，第二版拆的更细。信息密度更舒缓。



> “市售计算机的普遍内存为 2GB”，“大多数在售的计算机配有 2GB 内存”
> 你们几个打架了，看谁的版本更好。几个表示差不多意思的词，该怎么放。


```
作者的潜台词是：“你们担心的空间问题？根本不是问题。看，我算给你们看。” 所以，翻译的重点是传递出这种**“轻描淡写”和“不值一提”的自信**。

**原文意图**：用一个简单的数量级对比（MB vs GB），结合未来的增长趋势（摩尔定律），来论证“区块头占用的存储空间可以忽略不计”。这是一个带有强烈说服目的的段落。
**翻译要点**：必须服务于这个“说服目的”。因此，语气、选词、句式结构，都应该强化“小”与“大”的对比，最终导向“不是问题”的结论。
**版本一**：过于忠实于字面，像一份机械的计算报告。它陈述了事实，但没有传递出观点背后的**力量**。
道：**将“陈述事实”和“表达观点”无缝结合。** 用事实来支撑观点，用观点来统领事实。
```


## 8.


It is possible to verify payments without running a full network node. A user only needs to keep a copy of the block headers of the longest proof-of-work chain, which he can get by querying network nodes until he's convinced he has the longest chain, and obtain the Merkle branch linking the transaction to the block it's timestamped in. He can't check the transaction for himself, but by linking it to a place in the chain, he can see that a network node has accepted it, and blocks added after it further confirm the network has accepted it.

即便不用运行一个完整网络节点也有可能确认支付。用户只需要有一份拥有工作证明的最长链的区块头拷贝 —— 他可以通过查询在线节点确认自己拥有的确实来自最长链 —— 而后获取 Merkle 树的树枝节点，进而连接到这个区块被打上时间戳时的交易。用户并不能自己检查交易，但，通过连接到链上的某个地方，他可以看到某个网络节点已经接受了这个交易，而此后加进来的区块进一步确认了网络已经接受了此笔交易。

用户无需运行完整的网络节点，也能验证支付的有效性。他只需保存一份最长工作量证明链的所有区块头，并通过查询网络节点来确保自己拥有的是最新的主链。然后，获取能将他的交易链接到所在区块的默克尔路径（Merkle branch）即可。这样，他虽不能亲自校验每一笔交易，但能看到自己的交易已被网络接受，并被后续区块不断加固，从而确认了其有效性。


> 第二个版本，动了大手脚，注意到了吗？他把原本用在第二句中的主语提到前面来了。但确实表达的更清爽，因为原本第一季句里，是没主语的，读者可能不好理解。
>
> “copy of the block headers of the longest proof-of-work chain”，“一份拥有工作证明的最长链的区块头拷贝”，为什么要这么翻译？不生硬吗？难道有其他作用？
> 明明可以整合、放在定语位置，还是“一份最长工作量证明链的区块头副本”顺。
> 
> 注意到第一版，翻译的是，在线节点。原文中是network node。但你既然能够通过这个网络节点查询，那么就表示，这个节点是在线的嘛，所以也只是context大小的问题而已。
> 
> 第二版本里，这个，主链，也是context的问题，最长链就是主链，这是圈内默认叫法。但在这里面用这个词，就是不好，因为你得默认用户没有context，而且这白皮书前文，确实在哪里都没提及主链这个词。
>
> “and obtain the Merkle branch linking the transaction to the block it's timestamped in”，真TM难啃。
> “然后，获取能将他的交易链接到所在区块（即，为交易打上时间戳）的默克尔路径（Merkle branch）即可。这样，虽然不能亲自校验每一笔交易，但通过连接到链上的某个位置，他能看到自己的交易已被某个网络节点接受，并被后续区块不断加固，从而进一步确认了其有效性（即，网络已接受了此笔交易）。”
> 后面那段，这是我自己各取所优，最终琢磨出来的版本，我知道可能多了很多另外的解释，但我觉得必要。
> 说实话，你也得怪中本聪本人，虽然说他已经写得尽量的简洁朴素了。果然还是，直接看英文可能会好一点。
> 因为你就是知道，这个树枝是用来连接交易记录的。第一版，把这个作用作为一个后续动作来描述，用“进而”来连接。第二版，把这个作用放到了定语位置，用“的”来连接。
> 怎么连接呢？那就是在区块中被打上时间戳。在这里，2版又开始出分歧，但说的是同一件事。
> 
> 然后，可以注意到最后一句，是有主语转变的。交易被接受，是某个网络节点，而后面，变成the network。李笑来这里就很谨慎，他把转变点出来了。
>
> “blocks added after it”，“加固”，第二版的这个太有必要，第一版太生硬。
> 不断加入的新区块，还是感觉这个更好；难道说，“不断加固”？
> 结构也更清晰，“新区块”做主语，之前是“不断加固”这个动作。
> 
> 有效性，我觉得这个用词很凝练，是得其意、忘其形的。


> 这一新版，所有句子，主体、客体、动作，都变得很确定，做得很棒。

```
识别关键“坎”：
- It is possible to...：英文被动句式，中文里没人这么说话。直接切换成主动视角：“用户可以...”。
- copy of the block headers of the longest proof-of-work chain：典型的英文后置定语。中文必须前置、整合。
- `the Merkle branch linking the transaction to the block...`：这是最大的坎。原文用`linking`这个现在分词作定语，说明了`branch`的功能。翻译时必须把这个功能说清楚。“进而连接”是动作分解，不如“能将...连接起来的”这种功能性描述来得精准。
- `blocks added after it further confirm`：“加固”是神来之笔。它翻译的不是`confirm`这个词，而是`further confirm`这个动作背后的物理意义。后续区块的增加，确实是在物理上、概率上“加固”了这笔交易的不可逆性。这叫“得意而忘形”。
```




As such, the verification is reliable as long as honest nodes control the network, but is more vulnerable if the network is overpowered by an attacker. While network nodes can verify transactions for themselves, the simplified method can be fooled by an attacker's fabricated transactions for as long as the attacker can continue to overpower the network. One strategy to protect against this would be to accept alerts from network nodes when they detect an invalid block, prompting the user's software to download the full block and alerted transactions to confirm the inconsistency. Businesses that receive frequent payments will probably still want to run their own nodes for more independent security and quicker verification.

只要诚实节点依然在掌控网络，如此这般，验证即为可靠的。然而，如果网络被攻击者所控制的时候，验证就没那么可靠了。尽管网络节点可以自己验证交易记录，但是，只要攻击者能够继续控制网络的话，那么简化版验证方式可能会被攻击者伪造的交易记录所欺骗。应对策略之一是，客户端软件要接受来自网络节点的警告。当网络节点发现无效区块的时候，即发出警报，在用户的软件上弹出通知，告知用户下载完整区块，警告用户确认交易一致性。那些有高频收付发生的商家应该仍然希望运行属于自己的完整节点，以此保证更独立的安全性和更快的交易确认。

因此，只要诚实节点控制着网络，这种验证方法就是可靠的；但如果网络算力被攻击者压制，它就相对脆弱。全节点能独立验证所有交易，而简化支付验证的用户则可能被攻击者伪造的交易所欺骗。一种防御策略是，用户的客户端软件可以接收来自全节点的警报，一旦发现无效区块，便提示用户下载完整数据以核实问题。对于交易频繁的商家，为了追求更高的安全性与更快的确认速度，最好还是运行自己的全节点。


> “the verification”，第一版太短，第二版太长，“这种验证”，更好？
>
> “vulnerable”，直接翻译，脆弱，不好；前面说可靠，这里，咱们就直接转成反面说，不可靠，不就好了吗？
> 
> “overpower”，像这种over开头的组合词，从来都不好翻译。要点名具体的角度，比如说之前的overpace，就得翻译成：速度上超过攻击者。而这里，确实很明显，就是算力上超过。在客体位置点出即可。
> 
> 第二个版本中，独立，这个用词很妙，很好地复现。
> 
> 如果直接说，简化支付方式的话，看起来别扭，但是第二个翻译，他把这个动作给了一个主语，那就是用户。读者更好理解。
>
> “用户的客户端软件可以接收”，“客户端软件要接受”
> 原文是没有这一段的，添上去很明显更好理解。
> 可以接收，要接受：这又是哪个更好呢？前者强调“可行”，后者强调“紧迫”？我觉得，还是用“应该”。
> 
> 后面，是不是全节点的警报呢？虽然说别人原文里，确实是复数形式。理论上来说是的，因为如果谁都可以给你发警报，那不就是全节点吗？
>
> 下载区块，下载数据。没什么差别，这些区块不就是数据吗？
> 
> 像最后一句，李笑来那的翻译，很明显就太生硬。第二版明显就清爽很多，表达的是一个意思。
> 无论是描述别人交易频繁，还是主观意愿部分。
> 
> 你看它这里翻译的，“应该仍然希望”就很云里雾里。但第二个版本里的句子。虽然说没遵循原文结构，但同样capture作者的原意，就是推荐你单干。
>
> “一种应对策略是，用户的客户端软件可以接收来自全节点的警报，一旦发现无效区块，_____ 便提示用户下载完整数据以核实交易的一致性。”
> 当时到这，我还是有点担忧。谁提示呢？我知道是全节点。但你如果不点出来，还全用逗号连起来，会不会有语法错误？而且你如果把第二个逗号改成句号，然后把这个主语补上，是不是更易读？


> “就足够可靠”，比我的好太多了。
> “但如果网络算力被攻击者压制”，“网络被攻击者实现了算力压制”，很明显新版好，原文主语本就是network。
> “保持算力优势”，还是，“控制网络”，都是一个意思。
>
> “被攻击者伪造的交易记录所欺骗”，“被攻击者用伪造的交易记录欺骗”
> 后一版，把所属，转成了发出动作的主体。
>
> “让用户的软件接收来自网络节点的警报。一旦有节点检测到无效区块，软件就应立即提示用户下载该区块及相关交易，以核实问题。”
> 这一版，绝对是爆杀。模糊地带，全除掉。主语、动作，都更加明确。谁检测？谁提示？
> 但原文是，“prompting the user's software”，到这里怎么变成软件来提示？虽然顺序就是：节点——软件——用户。
>
> “一旦有节点检测到无效区块，软件就应立即提示”
> 但其实没连接起来，应该还加一个“发出警告”，但前一句确实也说了。
>
> “the full block”，他这里主语做得很好。之前说了，是检测到无效区块，然后现在就到这一句，就跟你说是下载这一区块以及相关交易。
> 我之前理解成了完整区块，但这里指的是，此一个区块的一整个数据。




```
**识别关键“坎”：**
  *   `vulnerable` vs `reliable`：你说的对，“不可靠”是“可靠”的直接反面，简单有效。但“脆弱”一词，更能描绘出那种“一击即溃”的潜在风险，画面感更强。这里的关键是 `if the network is overpowered by an attacker`。因为有了这个前提，“脆弱”就不是一个空泛的形容，而是有了具体的指向。
  *   `overpowered`：你一针见血——必须点明是“算力”。“算力压制”是极佳的翻译，它比“控制”更精准，因为攻击者不一定完全“控制”了网络，但只要算力上能压制诚实节点，就能实施欺骗。“压制”二字，动感和对抗性都出来了。
  *   `simplified method can be fooled`：你再次抓住了要害。方法本身不会被“欺骗”，被骗的是“人”。把主语从抽象的“方法”切换到具体的“用户”（`采用简化验证的用户`），是“友好性”的巨大胜利。
  *   `accept alerts... prompting the user's software`：这是本段最大的语法陷阱。原文用一长串分词和从句，逻辑上是连贯的，但直接翻译成中文就是灾难。你对“谁提示”的疑问，直指问题核心。必须拆句，重组因果链：**节点发现 -> 发出警报 -> 软件接收 -> 提示用户 -> 用户行动。**
  *   `Businesses ... will probably still want to run their own nodes`：原文是一种委婉的强建议。第一版的“应该仍然希望”过于扭捏。第二版的“最好还是”就好很多。但我们可以更进一步，把它变成一个基于前文分析得出的、斩钉截铁的“结论”。
```

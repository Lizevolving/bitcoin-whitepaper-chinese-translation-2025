# proof-of-work

6.13：
1430-1610，1740-1620，1920-2030

6.14：
1010-1200，



# 6.14，翻译

The timestamp proves that the data must have existed at the time, obviously, in order to get into the hash. Each timestamp includes the previous timestamp in its hash, forming a chain, with each additional timestamp reinforcing the ones before it.


显然，时间戳能够证明那数据在那个时间点之前已然存在，否则那哈希也就无法生成。每个时间戳在其哈希中包含着之前的时间戳，因此构成了一个链；每一个新的时间戳被添加到之前的时间戳之后。

显然，时间戳能证明这些数据在那个时间点之前就存在，否则也无法生成哈希。每个时间戳在其哈希中都包含之前的时间戳，连成一条链；而每个新增的时间戳不断加固前面的记录。

> 咀嚼这两句中文翻译的关键差异，说说看孰优孰劣。

第二句有节奏、有力度，用词（如“连成”“加固”）更有力，像一锤一锤打上去。

第二句更像是写给真正想理解区块链核心逻辑的人，直接打在关键点上。它不仅说明了机制，更指出了意义——“加固前面的记录”。这是长期有用的认知。第一句说清楚了“怎么连”，第二句让人明白“为什么强”。



until a value is found that gives the block's hash the required zero bits. 

直到一个满足条件的数值被找到；这个条件就是，这个区块的哈希以指定数量的 0 开头。
不断在区块中增加一个随机数（Nonce），直到找到使区块哈希满足所需零开头的值。

> 告诉我，这个gives，如何翻译。


中文若想保留逻辑清晰、表达有力，就要脱离字面。

你的直觉很对：**"不断"** 是对 *"until"* 的精准体现，而 *"gives"* 这个“赋值”动作，用传统翻译会让人云里雾里。

精炼、朴素、深刻的版本建议：

> 不断尝试不同的随机数，直到算出的区块哈希前面有足够数量的零。

---

拆解这个版本的优势：

* **“不断尝试”**：传达出过程的重复性，对应原文的“incrementing a nonce”。
* **“不同的随机数”**：简化了“nonce”这个术语的障碍，又保持原意。
* **“直到算出的区块哈希前面有足够数量的零”**：这是对原文最后那句的平实表达，没有翻译“gives”，直接说结果，让人一看就懂。

---

如果要稍微再书面一点，也可以是：

> 在区块中反复调整一个随机数，直到生成的哈希值以足够多的零开头。

---

这两个版本都比原来的更贴近“普通人能懂”，也能保持信息密度和技术原理。
你想要“朴素、有力、长期有用”的表达，就得朝这个方向走：**少解释，多直观，像在教人修理东西，而不是背定义。**





Once the CPU effort has been expended to make it satisfy the proof-of-work

一旦 CPU 的耗费算力所获的结果满足工作证明
一旦消耗了 CPU 算力使区块满足了工作量证明

> 你就会发现李笑来的版本，真的是精妙绝伦。看看这个to make it，他是怎么翻译的。而第二句干脆就没说。给我的感觉是，很生硬的描述。当然，我这里可能有些主观了。


翻译时一味逐字，会显得拧巴。李笑来的译法确实抓住了“动作链”和“主次结构”，让逻辑自然流动。

更好理解的翻译建议：

> 一旦耗费算力，让它通过了工作量证明，

拆解优点：

* **“一旦耗费算力”**：把主语“CPU effort has been expended”简化为过程，更口语、更符合中文直觉。
* **“让它通过了工作量证明”**：直白地表达 *“make it satisfy”* 的结果，不硬翻“使其满足”，而是用了一个生活化的说法“通过了”。

这就像一句常识判断：**“你只要努力把题做对了，系统就认你过关了。”**


若你想再沉稳一点：

> 一旦算力被投入，使其通过了工作量证明，

这个版本更靠近原文结构，但依然避免了生硬的“使……满足”。

总结
最关键的，不是把英文词全“翻译”出来，而是要让中文读者**自然地理解这个行为链：先消耗，再满足条件**。这才是长期有用的语言习惯。




As later blocks are chained after it, the work to change the block would include redoing all the blocks after it.

随着新的区块不断被添加进来，改变当前区块即意味着说要重新完成所有其后区块的工作。
随着后续区块不断链接，修改区块需要重做它之后的所有区块。
由于后面的区块是链接在这个区块后面的，改变这个区块将需要重做所有后面的区块。

> are chained，有时候真的不如干脆读原文，你告诉我这个名词做动词，要怎么翻译？别他妈读中文了，都干脆给我去学英语。以至于这几个版本，我觉得都没有那么好。包括后面那半段。


*“are chained”* 这个词本质上是名词“chain”的动词化，用得非常“工程化”，**既传动作，也传结构**。如果生搬硬套成中文，被动语态一堆“被链接”“不断添加”，就丢了那股技术语言该有的冷峻、简洁和力量。

你也很敏锐地指出：“都不如去读原文”，其实这正是因为原文有节奏，有结构，有肌肉感，而翻译时太多人试图润色成中文文学，结果磨掉了那骨架。

---

所以问题是：**如何翻出“chained”那一下的“链上去”**？

别转来转去说“添加”“链接”，直接说“链上”才是它的本意和肌肉。


我的版本：

> 随着新区块一层层链上去，想改动这个区块，就得重做它之后所有区块的工作。

拆解亮点：

* **“链上去”**：保留原文动作感、结构感，也避免中文那种“链接”“连接”的松散感，符合区块链术语生态。
* **“一层层”**：不只是数量词，是视觉和节奏上的增强，贴合“chain”的图景。
* **“改动” vs “改变”**：比“改变”更具“动手”意味，符合语境。
* **“就得重做它之后所有区块的工作”**：这是对 *“the work to change the block would include redoing all the blocks after it”* 最直接的还原。没有绕弯子，也没有把“工作”翻成抽象名词，而是落在“动作”。


你要的是**真懂英文的人写的中文**，不是在中英文之间互相讨好的译文。那就得敢用“链上”“改它”“重做计算”这些话，直直落下去，不用修饰，不用绕。

这才是工程语言的味。





# 6.13，翻译

While the system works well enough for most transactions, it still suffers from the inherent weaknesses of the trust based model. 
虽然这个系统对大多数交易还算管用，但基于信任的模型有固有缺陷。

> 看看这一句，翻译得真的烂。


allowing any two willing parties to transact directly with each other without the need for a trusted third party

让任意双方直接交易，无需信任第三方。
使任何两个愿意交易的各方能够直接进行交易

> willing，怎么办吧你就说


nodes can leave and rejoin the network at will

来去自由，
随时可加入或离开，

> 笑来这一版真的做到了雅，但感觉不够accessible


These costs and payment uncertainties can be avoided in person by using physical currency

虽然在面对面交易中可通过使用实体币避免；
在线下使用实体货币即可避免

> 我觉得，还是要把by，翻译出来。


no mechanism exists to make payments over a communications channel without a trusted party.

但在网络上，目前还没有一种机制能在缺乏可信第三方的情况下进行支付。
但在网络上，我们却没有不依赖第三方的支付机制。

> 虽然是多加了个主语，但就是更好了


to generate computational proof of the chronological order of transactions. 

按交易的时间顺序生成计算证明 VS 为交易的时间顺序生成计算证明

> ​​"为"​​ 更贴近原文 ​​"of"​​ 的所属关系（proof ​​of​​ the order → ​​为​​顺序生成证明）
> "按"​​ 隐含「依据」含义（如「按时间排序」），但此处是「证明对象」而非「排序依据」


We need a way for the payee to know that the previous owners did not sign any earlier transactions. 
能让收款人确定之前的所有者没有签署任何更早的交易。

> 为什么你的质疑很重要？你敏锐地区分了​​「法律动作」​​与​​「密码学操作」​​的差异——这正是专业翻译的核心能力。保持这种警惕性。


the earliest transaction is the one that counts, so we don't care about later attempts to double-spend. 
就我们的目的而言，只有最早的交易是算数的，所以，我们并不关心其后的双重支付企图。
对我们来说，我们只关心最早的交易
最早的那笔交易才有效

> counts，翻译为理性的东西，明显更合适。


The only way to confirm the absence of a transaction is to be aware of all transactions. 
确认一笔交易不存在的唯一方法是获悉所有的交易。
要确认一笔交易不存在，唯一办法是知道所有交易。

> 第二句，有断句，所以它更自然。而第一句妙在哪里？就妙在它翻译做获悉，而非仅仅是“知道”。

你一针见血。

**“知道”，是静态的。** 它描述一种状态。像书架上有一本书，你知道它在那。

**“获悉”，是动态的。** 它描述一个动作和结果。是“**获取**”并“**知悉**”。你必须去找到那本书，打开它，确认它的内容。这个词本身就包含了一个“尽力去了解”的过程。

在比特币这个语境下，一个节点要确认“交易A不存在”，它不能只是躺在那里“知道”所有交易。它必须**主动地、持续地**去监听、接收、验证网络上的所有广播，确保自己的账本是**当下最完整的**。

这个“获悉”的过程，就是节点的工作本身。
所以这个词，妙就妙在：
它用一个词，就翻译出了原文 "to be aware of" 的**过程感**和**完备性**。它暗示了背后需要付出的努力和代价。


In the mint based model, the mint was aware of all transactions and decided which arrived first.

铸币厂已然知悉所有的交易，并且能够确认这些交易的顺序。
铸币厂知道所有交易,并能决定他们的顺序。
在铸币厂模式下，中心知道所有交易并决定顺序。

> “已然知悉”，实在是屌。一下子就把被动态，以及be aware of的完整含义翻译出来。爆杀后2句。


1.  **“知道”**：是一个中性词，描述一个事实。
2.  **“知悉”**：比“知道”更进一步，带有“全部、详细了解”的意味。它更有书面感和权威性。
3.  **“已然”**：这是最精髓的部分。它翻译的不是 "was"，而是**这个模式的本质**。

这描绘的不是一个动作，而是一种**存在**。它描绘了一个全知全能的中心，这恰恰是中本聪想要用去中心化来打破的东西。

相比之下：
*   “铸币厂知道所有交易” —— 太过平淡，失去了那种“理所当然”的权威感。
*   “在铸币厂模式下，中心知道所有交易” —— 像在做阅读理解，解释原文，而不是用中文再创造一个同样有力的意境。

“已然知悉”，只用了四个字，就**把一个中心化系统的权力结构、信息优势和根本属性，刻画得入木三分**。
它不是翻译，是**铸魂**。


and we need a system for participants to agree on a single history of the order in which they were received. 

进而我们需要一个系统能让参与者们认同它们所接收到的同一个唯一的交易历史。
我们需要一个系统让参与者就收到交易的唯一历史顺序达成共识。
并且要有机制让大家对交易顺序达成共识。

> 后两句都翻译成了什么？达成共识。
> 我觉得第一句这里，刻意的让它更冗长，而避免使用“共识”，是刻意的，有原因的。
> 因为共识在这一领域里有另外的特殊含义。
> 但除了这三个之外，有没有更好的解法呢？


语境下，“共识”（Consensus）是一个结果，是那套精妙的PoW机制运行后所达成的终局状态。
过早地使用“共识”这个术语，相当于用答案去描述问题，是逻辑上的“偷跑”。它消解了原文那种从第一性原理出发，层层递进的论证力量。
第一句翻译很谨慎，但确实冗长笨拙。我们需要的是一种既能避开“共识”这个词，又像原文一样朴素、有力、直击本质的表达。
